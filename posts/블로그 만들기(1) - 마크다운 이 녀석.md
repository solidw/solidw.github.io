---
title: "블로그 만들기(1) - 마크다운 이 녀석"
description: "개발 블로그에 기본이라고 할 수 있는 마크다운 파서와 Syntax highlight 삽질을 들여다보자"
date: "2022-06-19"
---

# 마크다운?

- 텍스트 기반의 마크업 언어로 .. 대충 아래와 같이 변환된다.

```markdown
# 이런 걸 쓰면

## 이런 것도 쓰면
```

# 이런 걸 쓰면

## 이런 것도 쓰면

> 이렇게 # 제목은 h1 태그로 변환된다.

즉 블로그 글을 쓸 때 매번 `<h1>제목</h1>` `<code>const a = 1</code>` 이렇게 작성한다면 번거로우니, 마크다운 형식으로 포스팅을 작성하는 것이다. 이렇게 마크다운 형식으로 작성하면 마크다운 형식을 사용하는 다른 곳에 사용하기도 용이하다.(대표적으로 GitHub)

본론으로 돌아와서, 나의 블로그 제작 계획은 이러했다.
/posts/에 `포스팅.md` 형식으로 작성하고, 웹페이지를 렌더할 때(정확히는 빌드타임) 해당 파일을 읽어서 html로 변환하여 보여주는 것이다. 즉 내가 포스팅을 작성하기 위해서는 마크다운 파일을 `/posts/` 아래에 작성만 하면 되는 것이다.

우선 렌더하는 곳 `/posts/[postid]` 에서 getStaticPaths/getStaticProp를 통해 마크다운 파일을 읽도록 했다. 이 함수들은 빌드타임에 수행되어 빌드 후에는 다시 실행되지 않는 함수이다. (즉 유저가 접속할 때 마다 실행되는 것이 아니고 빌드 시에 호출한 getStaticXXX()의 결과물을 보여줄 것이다.)

```ts
export const getStaticPaths: GetStaticPaths = async () => {
  const dir = path.join(process.cwd(), "posts");
  const fileNames = fs.readdirSync(dir);

  const paths = fileNames.map((fileName) => ({
    params: { fileName: postUtils.getFileNameBase(fileName) },
  }));

  return {
    paths,
    fallback: false,
  };
};

export const getStaticProps: GetStaticProps = async ({ params }) => {
  if (params?.fileName == null) {
    throw new Error("fileName을 찾을 수 없습니다.");
  }

  const dir = path.join(process.cwd(), "posts");
  const fileName = `${dir}/${params.fileName}.md`;

  const content = fs.readFileSync(fileName, "utf8");
  const { attributes, body } = frontMatterParser<PostFrontMatters>(content);

  if (attributes.title == null) {
    throw new Error("title은 반드시 입력해야 합니다.");
  }

  const safeAttributes = postUtils.safeParseAttributes(attributes, {
    date: dateUtils.formatDate(fs.statSync(fileName).birthtime),
  });

  return {
    props: {
      attributes: safeAttributes,
      body,
    },
  };
};
```

> getStaticPaths와 getStaticProps에 대한 설명은 [next 도큐먼트](https://nextjs.org/docs/basic-features/data-fetching/get-static-paths)에 잘 설명되어 있다.

이 때 frontMatterParser 라는 것을 사용했는데, 포스팅의 메타데이터를 파일 맨 위에 선언해주기 위해 사용했다. yaml 파일 형식에서 많이 사용하는 듯 하다. 나는 예전에 jekyll을 이용한 깃허브 블로그를 만들 때 front matter를 사용했던 기억이 떠올라 사용해주었다.

```markdown
---
title: "블로그 만들기(1) - 마크다운 이 녀석"
description: "개발 블로그에 기본이라고 할 수 있는 마크다운 파서와 Syntax highlight 삽질을 들여다보자"
date: "2022-06-19"
---
```

> 이 포스팅의 front matter

작업을 요약하자면

1. 마크다운 파일을 불러와서
2. front matter를 분리한 본문(body)를 획득했다.

남은 작업은 아래의 3번 4번 정도인데..

3. markdown을 html로 바꾸어 렌더하기
4. syntax highlighting을 통해 고도화하기

이 때 markdown을 html로 바꾸어주는 라이브러리가 너무 많다보니 어떤 것을 써야할 지 고민이 되었다. 처음에는 `react-markdown` 라이브러리와 `reacy-syntax-highlighter` 라는 라이브러리로 구현했다. 엄청 금방 구현되어서 편리했지만 이 친구는 parse할 때 시간이 좀 걸리는 모양인지 새로고침할 때 마다 1초가 걸렸다. 물론 라이브 환경에서는 이 함수가 실행되지 않고 바로 포스트가 보이겠지만, 개발 환경에서 1초씩 잡아먹는 것은 내가 견딜 수 없었다. 그래서 조금 더 가벼운 라이브러리를 찾았다.

`remark`와 `prism`을 이용해 구현했다.

```ts
function MarkdownRenderer({ markdown }: { markdown: string }) {
  const htmlText = remark()
    .use(remarkParse)
    .use(remark2rehype)
    .use(html)
    .use(highlight, { prefix: "token " })
    .processSync(markdown)
    .toString();

  return <MarkdownRenderBlock dangerouslySetInnerHTML={{ __html: htmlText }} />;
}

const MarkdownRenderBlock = styled.div`
  line-height: 3rem;
  blockquote {
    box-shadow: ${createNeumorphismBoxShadow(1, 2, { inset: true })};
    margin: 0;
    padding: 15px;

    & > * {
      margin: 0;
    }
  }

  p > code {
    box-shadow: ${createNeumorphismBoxShadow(1, 2, { inset: true })};
    padding: 5px;
    margin-left: 3px;
    margin-right: 3px;
  }

  code[class*="language-"],
  pre[class*="language-"] {
    color: #000;
    background: 0 0;
    text-shadow: 0 1px #fff;
    font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
    font-size: 1em;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }
  code[class*="language-"] ::-moz-selection,
  code[class*="language-"]::-moz-selection,
  pre[class*="language-"] ::-moz-selection,
  pre[class*="language-"]::-moz-selection {
    text-shadow: none;
  }
  code[class*="language-"] ::selection,
  code[class*="language-"]::selection,
  pre[class*="language-"] ::selection,
  pre[class*="language-"]::selection {
    text-shadow: none;
    background: #b3d4fc;
  }
  @media print {
    code[class*="language-"],
    pre[class*="language-"] {
      text-shadow: none;
    }
  }
  pre[class*="language-"] {
    padding: 1em;
    margin: 0.5em 0;
    overflow: auto;
  }
  :not(pre) > code[class*="language-"],
  pre {
    background: ${theme.palette.primary.light};
    box-shadow: ${createNeumorphismBoxShadow(3, 5, { inset: true })};
    background: none;
    border: none;
    padding: 15px;
  }
  :not(pre) > code[class*="language-"] {
    padding: 0.1em;
    border-radius: 0.3em;
    white-space: normal;
  }
  .token.cdata,
  .token.comment,
  .token.doctype,
  .token.prolog {
    color: #708090;
  }
  .token.punctuation {
    color: #999;
  }
  .token.namespace {
    opacity: 0.7;
  }
  .token.boolean,
  .token.constant,
  .token.deleted,
  .token.number,
  .token.property,
  .token.symbol,
  .token.tag {
    color: #905;
  }
  .token.attr-name,
  .token.builtin,
  .token.char,
  .token.inserted,
  .token.selector,
  .token.string {
    color: #690;
  }
  .language-css .token.string,
  .style .token.string,
  .token.entity,
  .token.operator,
  .token.url {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, 0.5);
  }
  .token.atrule,
  .token.attr-value,
  .token.keyword {
    color: #07a;
  }
  .token.class-name,
  .token.function {
    color: #dd4a68;
  }
  .token.important,
  .token.regex,
  .token.variable {
    color: #e90;
  }
  .token.bold,
  .token.important {
    font-weight: 700;
  }
  .token.italic {
    font-style: italic;
  }
  .token.entity {
    cursor: help;
  }
`;
```

> 파싱 후 스타일은 적절히 커스텀으로 입혀준다.

각각의 함수가 정확히 어떤 역할을 하는지는 잘 모르지만 지금 나는 포스팅을 작성하고 싶은 것이지, remark, rehype의 역사가 알고 싶은 것이 아니었다. 대충 예제 코드들로 잘 동작하는 것을 확인하고, 새로고침 시 딜레이가 느껴지지 않을 정도로 빠른 것을 확인했다.

코드는 더 간단해지고 렌더하는 데 걸리는 시간도 줄어들었다. 만족스러웠다.
